(setq gene1 '(1 0 0 0 1 x 1 0 1 1))	;test gene to use in the procedures(setq gene2 '(1 0 0 0 1 x 1 1 0 1))(setq alleles '(1 0))			;the possible alleles to occupy a bit on the gene(setq fraction-weak-wins 0.5)	;fraction of the time that the weaker gene wins a trounament(setq number-generations 50)	;the number of generations to compute(setq target-value 221)			;the number to be factored(setq gene-length 10)			;the number of bits stored in the gene(setq population-size 1000)		;the size of the population of genes to be used(setq mutate-rate 0.001)		;the rate of mutations in the population(defun header (string)	"takes the first half of a gene and converts it to a string of binary digits"	(cond ((equal 'x (car string)) ())	      (T (cons (car string) (header(cdr string))))))(defun tailer (string)	"takes the second half of a gene and converts it to a string of binary digits"	(reverse(header(reverse string))))(defun make-number (string)	"converts a string of binary digits to a decimal equivalent"	(setq result 0)	(cond ((= (length string) 1) (car string))	      (T (+ result (* (expt 2 (- (length string) 1)) (car string)) (make-number (cdr string))))))(defun gene-value (gene)	"interprets the value of the gene, by multiplying to two halves together to     get a decimal number"    (* (make-number (header gene)) (make-number (tailer gene))))(defun fitness (gene)	"the fitness function for the gene, calculated simply by determining the absolute	 difference from the target-value -- the number to be factored"	(abs (- (gene-value gene) target-value)))(defun head (number gene)	"take the first number bits of gene and make those into a string"	(setq count 0)	(cond ((= number count) ())	      (T (cons (car gene) (head (- number 1) (cdr gene))))))(defun tail (number gene)	"take the last number bits of gene and make those into a string"	(reverse (head number (reverse gene))))(defun cross-over (gene-pair)	"perform cross over on a list of two genes, gene-pair, and return a gene-pair	 of two daughter genes"	 (setq mother (car gene-pair))    ;decompose the gene-pair into the two parents	 (setq father (cadr gene-pair))	 (setq cross-point (random (length mother)))	;pick a point on the gene to perform the crossover	 (print cross-point)	 (setq daughter1 (append (head (- cross-point 1) mother) (tail (+ (- (length mother) cross-point) 1) father)))	 (setq daughter2 (append (head (- cross-point 1) father) (tail (+ (- (length mother) cross-point) 1) mother)))	 (list daughter1 daughter2))(defun pick-point (index gene)	"return the element of the list stored at the point index, moving from left to right	 counting starts at 0"	(setq count 0)	(cond ((= count index) (car gene))	      (T (pick-point (- index 1) (cdr gene)))))(defun change-point (index change-to string)	"change the point on string at index to change-to"	(setq count 0)	(cond ((= count index) (cons change-to (cdr string)))		  (T (cons (car string) (change-point (- index 1) change-to (cdr string))))))(defun mutate (gene)	"perform a mutation to a random point on the gene passed, changing it to 	 a randomly selected member of alleles"	(setq mutate-point (random (length gene)))	(setq mutate-to (pick-point (random (- (length alleles) 1)) alleles))	(print mutate-point)	(print mutate-to)	(change-point mutate-point mutate-to gene))(defun make-random-allele ()	"return an atom as a random allele"	(pick-point (random (length alleles)) alleles))(defun make-random-gene (length-to-make)	"create a gene out of randomly selected parts	 make the gene full of random 1's and 0's in the current case	 the x will be added by a point mutation later"	(setq count 0)	(setq result ())	(cond ((= count length-to-make) ())	      (T (cons (make-random-allele) (make-random-gene (- length-to-make 1))))))(defun fitter-gene (gene1 gene2)	"return the fitter of the two gene passed to the function"	(cond ((< (fitness gene1) (fitness gene2)) gene1)		  (T gene2)))(defun less-fit-gene (gene1 gene2)	"return the less fit gene of the two passed to the function"	(cond ((> (fitness gene1) (fitness gene2)) gene1)	      (T gene2)))(defun tournament (gene1 gene2)	"create a tournament and pick the more fit 1-fraction-weak-wins of the time	 otherwise pick the more fit gene"	(setq weak-wins (random 1.0))	;pick a random number to test if the weak gene wins the tournament	(cond ((= (max weak-wins fraction-weak-wins) fraction-weak-wins) (fitter-gene gene1 gene2))	      (T (less-fit-gene gene1 gene2))))(defun make-random-population (size-of-pop)	"create an array holding a random population specified by size-of-pop"	(setq pop1 (make-array size-of-pop))	(setq count 0)	(setq population nil)	(do ((count 0 (1+ count)))		((= count size-of-pop) population)		(setq mutate-spot (random gene-length))		(setq new-member (make-random-gene gene-length))	    (setq new-member (change-point mutate-spot 'x new-member))		(setq population (cons new-member population))))(defun average-fitness (population)	"compute the average fitness of a given population"	(setq avgfitness 0)	(do ((count 0 (1+ count)))		((= count (- population-size 1)) (/ avgfitness population-size))		(setq avgfitness (+ avgfitness (fitness (nth count population))))))(defun main ()	"the main program function"	(setq pop1 (make-random-population population-size) ;make an initial random population of genes	(setq finalpop (do  ((count 0 (1+ count)))					    ((= count number-generations) population)						;the following will be reapeated population-size/4 times to fill the						;next generation						(do ((count2 0 (1+ count2)))							((= count2 (/ population-size 4)) ())							;pick two genes at random from the population and conduct a tournament with							;the two.  the winner becomes the mother							(setq competitor1 (nth (random (- population-size 1)) pop1))							(setq competitor2 (nth (random (- population-size 1)) pop1))							(setq mother (tournament competitor1 competitor2))							;pick another two genes and conduct a tournament to pick the father							(setq competitor1 (nth (random (- population-size 1)) pop1))							(setq competitor2 (nth (random (- population-size 1)) pop1))							(setq father (tournament competitor1 competitor2))							;perform crossover on the two parents to produce two daughter genes							(setq daughters (cross-over (cons mother father)))							;extract the daughters to individual genes from the gene pair daughters							(setq daughter1 (car daughters))							(setq daughter2 (cadr daughters))							;determine if a mutation occurs on any of the parents or daughters							;and mutate the sicko							(setq mutationQ (random 1.0))							(cond ((> mutationQ mutate-rate) ())	;no mutation occurs							  (T ((setq sicko (random 3))								  (cond ((= 0 sicko) (setq mother (mutate mother)))										((= 1 sicko) (setq father (mutate father)))										((= 2 sicko) (setq daughter1 (mutate daughter1)))										((= 3 sicko) (setq daughter2 (mutate daughter2)))))))							;copy the parents and the daughters into the new generation							(setq population (cons mother population))							(setq population (cons father population))							(setq population (cons daughter1 population))							(setq population (cons daughter2 population))							;the essential elements of one generation shoul now be complete, this 							;will then be repeated population-size/4 times							;any population checking code can then be inserted after this														)))	;all of the generations should now be complete, and finalpop is the final population							